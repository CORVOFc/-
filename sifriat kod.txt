ğŸ”· SEÃ‡ÃƒO 1 â€” SeleÃ§Ã£o e ManipulaÃ§Ã£o de Elementos DOM
javascript
// Seleciona um Ãºnico elemento pelo seletor CSS
const titulo = document.querySelector(".titulo");

// Altera o conteÃºdo textual do elemento selecionado
titulo.textContent = "Aparecida Nutricionista";
ğŸ§  ComentÃ¡rio tÃ©cnico: querySelector retorna o primeiro elemento que corresponde ao seletor. textContent altera o conteÃºdo visÃ­vel, sem afetar atributos ou estrutura interna.

ğŸ“Œ Contexto de uso: AtualizaÃ§Ã£o dinÃ¢mica de tÃ­tulos, mensagens ou labels em pÃ¡ginas interativas.

javascript
// Seleciona todos os elementos com a classe .paciente
const pacientes = document.querySelectorAll(".paciente");

// Itera sobre cada paciente para aplicar lÃ³gica individual
for (let i = 0; i < pacientes.length; i++) {
    const paciente = pacientes[i];
    // lÃ³gica aplicada ao paciente
}
ğŸ§  ComentÃ¡rio tÃ©cnico: querySelectorAll retorna um NodeList, que pode ser percorrido com for, forEach, ou Array.from().

ğŸ“Œ Contexto de uso: Processamento em massa de elementos como linhas de tabela, cards ou inputs.

ğŸ”· SEÃ‡ÃƒO 2 â€” ConversÃ£o e ValidaÃ§Ã£o de Dados NumÃ©ricos
javascript
// Converte texto para nÃºmero decimal
const peso = parseFloat(paciente.querySelector(".info-peso").textContent);
const altura = parseFloat(paciente.querySelector(".info-altura").textContent);
ğŸ§  ComentÃ¡rio tÃ©cnico: parseFloat Ã© essencial para garantir que operaÃ§Ãµes matemÃ¡ticas sejam feitas com nÃºmeros reais. Evita erros silenciosos de concatenaÃ§Ã£o de strings.

ğŸ“Œ Contexto de uso: CÃ¡lculos, validaÃ§Ãµes, comparaÃ§Ãµes numÃ©ricas, grÃ¡ficos.

javascript
// ValidaÃ§Ã£o de intervalo seguro para peso e altura
const pesoEhValido = peso > 0 && peso < 1000;
const alturaEhValida = altura > 0 && altura < 3.0;
ğŸ§  ComentÃ¡rio tÃ©cnico: ValidaÃ§Ãµes devem ser feitas antes de qualquer cÃ¡lculo. Evita divisÃ£o por zero, resultados absurdos ou falhas visuais.

ğŸ“Œ Contexto de uso: FormulÃ¡rios mÃ©dicos, cadastros, dashboards de saÃºde.

ğŸ”· SEÃ‡ÃƒO 3 â€” CÃ¡lculo e FormataÃ§Ã£o de Resultados
javascript
// CÃ¡lculo do IMC com formataÃ§Ã£o
if (pesoEhValido && alturaEhValida) {
    const imc = peso / (altura * altura);
    paciente.querySelector(".info-imc").textContent = imc.toFixed(2);
}
ğŸ§  ComentÃ¡rio tÃ©cnico: .toFixed(2) garante consistÃªncia visual e evita excesso de casas decimais. O cÃ¡lculo segue a fÃ³rmula padrÃ£o do IMC.

ğŸ“Œ Contexto de uso: AplicaÃ§Ãµes de saÃºde, academias, clÃ­nicas, apps de nutriÃ§Ã£o.

ğŸ”· SEÃ‡ÃƒO 4 â€” Feedback Visual e EstilizaÃ§Ã£o DinÃ¢mica
javascript
// Aplica estilo de erro em campos invÃ¡lidos
if (!pesoEhValido) {
    paciente.querySelector(".info-peso").classList.add("campo-invalido");
    paciente.style.backgroundColor = "salmon";
}
ğŸ§  ComentÃ¡rio tÃ©cnico: classList.add permite aplicar estilos definidos no CSS. style.backgroundColor altera diretamente o estilo inline.

ğŸ“Œ Contexto de uso: ValidaÃ§Ã£o de formulÃ¡rios, alertas visuais, UX responsiva.

ğŸ”· SEÃ‡ÃƒO 5 â€” Encapsulamento em FunÃ§Ãµes ReutilizÃ¡veis
javascript
function calcularIMC(paciente) {
    const peso = parseFloat(paciente.querySelector(".info-peso").textContent);
    const altura = parseFloat(paciente.querySelector(".info-altura").textContent);
    const imcField = paciente.querySelector(".info-imc");

    const pesoEhValido = peso > 0 && peso < 1000;
    const alturaEhValida = altura > 0 && altura < 3.0;

    if (!pesoEhValido) {
        paciente.querySelector(".info-peso").classList.add("campo-invalido");
        imcField.textContent = "Peso invÃ¡lido";
        paciente.style.backgroundColor = "salmon";
        return;
    }

    if (!alturaEhValida) {
        paciente.querySelector(".info-altura").classList.add("campo-invalido");
        imcField.textContent = "Altura invÃ¡lida";
        paciente.style.backgroundColor = "salmon";
        return;
    }

    const imc = peso / (altura * altura);
    imcField.textContent = imc.toFixed(2);
}
ğŸ§  ComentÃ¡rio tÃ©cnico: FunÃ§Ãµes encapsulam lÃ³gica, reduzem repetiÃ§Ã£o e aumentam legibilidade. Ideal para modularizaÃ§Ã£o e testes unitÃ¡rios.

ğŸ“Œ Contexto de uso: Componentes reutilizÃ¡veis, sistemas escalÃ¡veis, bibliotecas internas.

ğŸŸ¦ SEÃ‡ÃƒO 7 â€” Estrutura de Tabela HTML
html
<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Peso</th>
      <th>Altura</th>
      <th>IMC</th>
    </tr>
  </thead>
  <tbody>
    <tr class="paciente">
      <td class="info-nome">JoÃ£o</td>
      <td class="info-peso">80</td>
      <td class="info-altura">1.75</td>
      <td class="info-imc">0</td>
    </tr>
  </tbody>
</table>
ExplicaÃ§Ã£o: Estrutura bÃ¡sica de uma tabela com dados de pacientes. Cada cÃ©lula tem uma classe especÃ­fica para facilitar a manipulaÃ§Ã£o via JavaScript.


ğŸŸ¨ SEÃ‡ÃƒO 8 â€” Eventos e Interatividade com JavaScript
ğŸ”¹ Detectar clique em botÃ£o
javascript
var botao = document.querySelector("#botao-adicionar");
botao.addEventListener("click", function() {
    console.log("BotÃ£o clicado!");
});
ExplicaÃ§Ã£o: Escuta o clique no botÃ£o com ID botao-adicionar e executa uma funÃ§Ã£o. Ideal para acionar aÃ§Ãµes como adicionar dados ou abrir modais.

ğŸ”¹ Prevenir comportamento padrÃ£o (como envio de formulÃ¡rio)
javascript
form.addEventListener("submit", function(event) {
    event.preventDefault();
});
ExplicaÃ§Ã£o: Impede que o formulÃ¡rio seja enviado automaticamente. Usado para validar dados antes de enviar ou para manipular o envio via JavaScript.

ğŸ”¹ Capturar valor de um campo de texto
javascript
var nome = document.querySelector("#campo-nome").value;
ExplicaÃ§Ã£o: Pega o valor digitado pelo usuÃ¡rio no campo com ID campo-nome. Pode ser usado para validaÃ§Ã£o ou para exibir em outro lugar.

ğŸ”¹ Validar se campo estÃ¡ vazio
javascript
if (nome.trim() === "") {
    alert("O campo nome nÃ£o pode estar vazio.");
}
ExplicaÃ§Ã£o: Verifica se o campo estÃ¡ vazio ou sÃ³ tem espaÃ§os. trim() remove espaÃ§os antes e depois do texto.

ğŸ”¹ Adicionar novo paciente Ã  tabela
javascript
var linha = document.createElement("tr");
linha.classList.add("paciente");

var celulaNome = document.createElement("td");
celulaNome.classList.add("info-nome");
celulaNome.textContent = nome;

linha.appendChild(celulaNome);
tabela.appendChild(linha);
ExplicaÃ§Ã£o: Cria uma nova linha na tabela com os dados do paciente. Pode ser expandido para incluir peso, altura, gordura e IMC.

ğŸ”¹ Resetar formulÃ¡rio apÃ³s envio
javascript
form.reset();
ExplicaÃ§Ã£o: Limpa todos os campos do formulÃ¡rio. Usado apÃ³s adicionar dados com sucesso.

ğŸ”¹ Mostrar mensagem de erro visual
javascript
campo.classList.add("campo-invalido");
ExplicaÃ§Ã£o: Aplica estilo visual (como borda vermelha) ao campo com erro. A classe deve estar definida no CSS.

ğŸ”¹ Remover classe de erro
javascript
campo.classList.remove("campo-invalido");
ExplicaÃ§Ã£o: Remove o estilo de erro quando o campo Ã© corrigido. Ideal para feedback visual dinÃ¢mico.

ğŸŸ¨ SEÃ‡ÃƒO 9 â€” Eventos e FormulÃ¡rios AvanÃ§ados (JavaScript)
Esta seÃ§Ã£o cobre interaÃ§Ãµes complexas com formulÃ¡rios, validaÃ§Ãµes em tempo real, manipulaÃ§Ã£o de eventos e feedback dinÃ¢mico.

ğŸ”¹ Escutar mÃºltiplos eventos em um campo
javascript
const campoEmail = document.querySelector("#email");

campoEmail.addEventListener("focus", () => {
    campoEmail.classList.add("campo-ativo");
});

campoEmail.addEventListener("blur", () => {
    campoEmail.classList.remove("campo-ativo");
});

campoEmail.addEventListener("input", () => {
    validarEmail(campoEmail.value);
});
ğŸ§  ComentÃ¡rio tÃ©cnico: focus e blur controlam o estado visual do campo. input permite validaÃ§Ã£o em tempo real conforme o usuÃ¡rio digita.

ğŸ“Œ Contexto de uso: UX responsiva, formulÃ¡rios inteligentes, validaÃ§Ã£o progressiva.

ğŸ”¹ ValidaÃ§Ã£o de e-mail com regex
javascript
function validarEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const valido = regex.test(email);

    if (!valido) {
        campoEmail.classList.add("campo-invalido");
    } else {
        campoEmail.classList.remove("campo-invalido");
    }
}
ğŸ§  ComentÃ¡rio tÃ©cnico: ExpressÃµes regulares sÃ£o poderosas para validar padrÃµes. Este regex cobre e-mails comuns sem exigir domÃ­nio tÃ©cnico do usuÃ¡rio.

ğŸ“Œ Contexto de uso: FormulÃ¡rios de login, cadastro, newsletter.

ğŸ”¹ Capturar e processar envio de formulÃ¡rio
javascript
const form = document.querySelector("#formulario");

form.addEventListener("submit", function(event) {
    event.preventDefault();

    const dados = new FormData(form);
    const nome = dados.get("nome");
    const email = dados.get("email");

    console.log("Dados enviados:", nome, email);
});
ğŸ§  ComentÃ¡rio tÃ©cnico: FormData permite capturar todos os campos do formulÃ¡rio sem precisar selecionar cada um manualmente.

ğŸ“Œ Contexto de uso: APIs, envio AJAX, integraÃ§Ã£o com backend.

ğŸ”¹ ValidaÃ§Ã£o de mÃºltiplos campos com feedback visual
javascript
function validarFormulario() {
    const campos = document.querySelectorAll(".campo-obrigatorio");

    campos.forEach(campo => {
        if (campo.value.trim() === "") {
            campo.classList.add("campo-invalido");
        } else {
            campo.classList.remove("campo-invalido");
        }
    });
}
ğŸ§  ComentÃ¡rio tÃ©cnico: forEach permite aplicar lÃ³gica a todos os campos obrigatÃ³rios. trim() evita espaÃ§os em branco como entrada vÃ¡lida.

ğŸ“Œ Contexto de uso: FormulÃ¡rios robustos, UX acessÃ­vel, validaÃ§Ã£o antes de envio.

ğŸŸ¦ SEÃ‡ÃƒO 10 â€” AnimaÃ§Ãµes CSS e TransiÃ§Ãµes
Esta seÃ§Ã£o cobre efeitos visuais suaves, transiÃ§Ãµes entre estados e animaÃ§Ãµes que melhoram a experiÃªncia do usuÃ¡rio.

ğŸ”¹ TransiÃ§Ã£o suave de cor ao passar o mouse
css
.botao {
    background-color: #0c8cd3;
    transition: background-color 0.3s ease;
}

.botao:hover {
    background-color: #04324c;
}
ğŸ§  ComentÃ¡rio tÃ©cnico: transition aplica suavidade Ã  mudanÃ§a de cor. ease define uma curva de aceleraÃ§Ã£o natural.

ğŸ“Œ Contexto de uso: BotÃµes interativos, menus, feedback visual.

ğŸ”¹ AnimaÃ§Ã£o de entrada com @keyframes
css
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.card {
    animation: fadeIn 0.5s ease-out forwards;
}
ğŸ§  ComentÃ¡rio tÃ©cnico: @keyframes define os estados da animaÃ§Ã£o. forwards mantÃ©m o estado final apÃ³s a execuÃ§Ã£o.

ğŸ“Œ Contexto de uso: Cards, modais, elementos que aparecem dinamicamente.

ğŸ”¹ AnimaÃ§Ã£o contÃ­nua (loop infinito)
css
@keyframes girar {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.icone-carregando {
    animation: girar 1s linear infinite;
}
ğŸ§  ComentÃ¡rio tÃ©cnico: infinite repete a animaÃ§Ã£o sem parar. linear mantÃ©m velocidade constante.

ğŸ“Œ Contexto de uso: Indicadores de carregamento, Ã­cones animados, feedback de espera.

ğŸ”¹ TransiÃ§Ã£o de mÃºltiplas propriedades
css
.card {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
ğŸ§  ComentÃ¡rio tÃ©cnico: TransiÃ§Ãµes podem ser aplicadas a vÃ¡rias propriedades simultaneamente. scale aumenta o tamanho, box-shadow adiciona profundidade.

ğŸ“Œ Contexto de uso: Efeitos de destaque, interaÃ§Ãµes visuais, microinteraÃ§Ãµes.

Se quiser, posso continuar com seÃ§Ãµes sobre responsividade com media queries, integraÃ§Ã£o com APIs usando fetch, ou componentizaÃ§Ã£o com React. Qual tema vocÃª quer explorar na prÃ³xima expansÃ£o?

Perfeito! Vamos aprofundar sua biblioteca com duas seÃ§Ãµes tÃ©cnicas e extensas: Eventos e FormulÃ¡rios AvanÃ§ados e AnimaÃ§Ãµes CSS e TransiÃ§Ãµes. Cada item vem com cÃ³digo, explicaÃ§Ã£o tÃ©cnica e contexto de uso â€” ideal para projetos profissionais e estudo contÃ­nuo.

ğŸŸ¨ SEÃ‡ÃƒO 11 â€” Eventos e FormulÃ¡rios AvanÃ§ados (JavaScript)
ğŸ”¹ Escutar mÃºltiplos eventos em campos de formulÃ¡rio
javascript
const campo = document.querySelector("#nome");

campo.addEventListener("focus", () => campo.classList.add("ativo"));
campo.addEventListener("blur", () => campo.classList.remove("ativo"));
campo.addEventListener("input", () => validarCampo(campo));
ğŸ§  TÃ©cnico: focus e blur controlam o estado visual do campo. input permite validaÃ§Ã£o em tempo real.

ğŸ“Œ Uso: FormulÃ¡rios interativos, UX responsiva.

ğŸ”¹ ValidaÃ§Ã£o com regex (e-mail)
javascript
function validarEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}
ğŸ§  TÃ©cnico: ExpressÃ£o regular que cobre formatos comuns de e-mail. Retorna true ou false.

ğŸ“Œ Uso: Cadastro, login, newsletter.

ğŸ”¹ Capturar envio de formulÃ¡rio e impedir comportamento padrÃ£o
javascript
const form = document.querySelector("#formulario");

form.addEventListener("submit", function(event) {
  event.preventDefault();
  const dados = new FormData(form);
  const nome = dados.get("nome");
  const email = dados.get("email");
  console.log("Enviado:", nome, email);
});
ğŸ§  TÃ©cnico: FormData extrai os dados sem precisar acessar cada campo manualmente.

ğŸ“Œ Uso: IntegraÃ§Ã£o com APIs, envio AJAX.

ğŸ”¹ ValidaÃ§Ã£o de mÃºltiplos campos obrigatÃ³rios
javascript
function validarCamposObrigatorios() {
  const campos = document.querySelectorAll(".obrigatorio");

  campos.forEach(campo => {
    if (campo.value.trim() === "") {
      campo.classList.add("erro");
    } else {
      campo.classList.remove("erro");
    }
  });
}
ğŸ§  TÃ©cnico: trim() remove espaÃ§os. forEach aplica a todos os campos.

ğŸ“Œ Uso: FormulÃ¡rios robustos, feedback visual.

ğŸ”¹ Resetar formulÃ¡rio apÃ³s envio
javascript
form.reset();
ğŸ§  TÃ©cnico: Limpa todos os campos do formulÃ¡rio.

ğŸ“Œ Uso: ApÃ³s envio bem-sucedido, para preparar novo preenchimento.

ğŸŸ¦ SEÃ‡ÃƒO 12 â€” AnimaÃ§Ãµes CSS e TransiÃ§Ãµes
ğŸ”¹ TransiÃ§Ã£o suave de cor ao passar o mouse
css
.botao {
  background-color: #0c8cd3;
  transition: background-color 0.3s ease;
}

.botao:hover {
  background-color: #04324c;
}
ğŸ§  TÃ©cnico: transition suaviza a mudanÃ§a de cor. ease aplica curva de aceleraÃ§Ã£o.

ğŸ“Œ Uso: BotÃµes, menus, interaÃ§Ãµes visuais.

ğŸ”¹ AnimaÃ§Ã£o de entrada com @keyframes
css
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.card {
  animation: fadeIn 0.5s ease-out forwards;
}
ğŸ§  TÃ©cnico: @keyframes define os estados da animaÃ§Ã£o. forwards mantÃ©m o estado final.

ğŸ“Œ Uso: Cards, modais, elementos dinÃ¢micos.

ğŸ”¹ AnimaÃ§Ã£o contÃ­nua (loop infinito)
css
@keyframes girar {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.icone-carregando {
  animation: girar 1s linear infinite;
}
ğŸ§  TÃ©cnico: infinite repete sem parar. linear mantÃ©m velocidade constante.

ğŸ“Œ Uso: Indicadores de carregamento, Ã­cones animados.

ğŸ”¹ TransiÃ§Ã£o de mÃºltiplas propriedades
css
.card {
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
ğŸ§  TÃ©cnico: scale aumenta o tamanho. box-shadow adiciona profundidade.

ğŸ“Œ Uso: Destaque visual, microinteraÃ§Ãµes.
